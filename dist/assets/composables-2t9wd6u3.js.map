{"version":3,"file":"composables-2t9wd6u3.js","sources":["../../src/tour/composables/useDraggable.js","../../src/tour/composables/useHighlightTracker.js","../../src/composables/useErrorHandling.js","../../src/composables/useD3.js"],"sourcesContent":["import { ref, onMounted, onUnmounted } from 'vue'\n\nexport function useDraggable(elementRef, options = {}) {\n  const {\n    initialPosition = { x: 0, y: 0 },\n    handle = null,\n    bounds = 'viewport',\n    onDragStart = null,\n    onDrag = null,\n    onDragEnd = null\n  } = options\n\n  const position = ref({ ...initialPosition })\n  const isDragging = ref(false)\n  const dragOffset = ref({ x: 0, y: 0 })\n  const hasMoved = ref(false)\n\n  let dragHandle = null\n\n  const handleMouseDown = (e) => {\n    // Prevent text selection during drag\n    e.preventDefault()\n    \n    const element = elementRef.value\n    if (!element) return\n\n    const rect = element.getBoundingClientRect()\n    \n    // Calculate offset from mouse to element position\n    dragOffset.value = {\n      x: e.clientX - rect.left,\n      y: e.clientY - rect.top\n    }\n\n    isDragging.value = true\n    hasMoved.value = false\n\n    // Add document listeners\n    document.addEventListener('mousemove', handleMouseMove)\n    document.addEventListener('mouseup', handleMouseUp)\n    \n    // Lock cursor style\n    document.body.style.cursor = 'grabbing'\n    \n    if (onDragStart) {\n      onDragStart({ x: rect.left, y: rect.top })\n    }\n  }\n\n  const handleMouseMove = (e) => {\n    if (!isDragging.value) return\n\n    hasMoved.value = true\n\n    let newX = e.clientX - dragOffset.value.x\n    let newY = e.clientY - dragOffset.value.y\n\n    // Apply bounds constraint\n    if (bounds === 'viewport') {\n      const element = elementRef.value\n      if (element) {\n        const rect = element.getBoundingClientRect()\n        const padding = 20\n\n        // Constrain to viewport\n        newX = Math.max(padding, Math.min(newX, window.innerWidth - rect.width - padding))\n        newY = Math.max(padding, Math.min(newY, window.innerHeight - rect.height - padding))\n      }\n    }\n\n    position.value = { x: newX, y: newY }\n\n    if (onDrag) {\n      onDrag({ x: newX, y: newY })\n    }\n  }\n\n  const handleMouseUp = () => {\n    if (!isDragging.value) return\n\n    isDragging.value = false\n    \n    // Remove document listeners\n    document.removeEventListener('mousemove', handleMouseMove)\n    document.removeEventListener('mouseup', handleMouseUp)\n    \n    // Reset cursor\n    document.body.style.cursor = ''\n\n    if (onDragEnd && hasMoved.value) {\n      onDragEnd(position.value)\n    }\n  }\n\n  const setPosition = (newPosition) => {\n    position.value = { ...newPosition }\n  }\n\n  onMounted(() => {\n    const element = elementRef.value\n    if (!element) return\n\n    // Determine drag handle\n    if (handle) {\n      dragHandle = typeof handle === 'string' \n        ? element.querySelector(handle)\n        : handle.value || handle\n    } else {\n      dragHandle = element\n    }\n\n    if (dragHandle) {\n      dragHandle.addEventListener('mousedown', handleMouseDown)\n      dragHandle.style.cursor = 'grab'\n    }\n  })\n\n  onUnmounted(() => {\n    if (dragHandle) {\n      dragHandle.removeEventListener('mousedown', handleMouseDown)\n    }\n    \n    // Clean up any active drag\n    if (isDragging.value) {\n      document.removeEventListener('mousemove', handleMouseMove)\n      document.removeEventListener('mouseup', handleMouseUp)\n      document.body.style.cursor = ''\n    }\n  })\n\n  return {\n    position,\n    isDragging,\n    hasMoved,\n    setPosition\n  }\n}","import { ref, onMounted, onUnmounted } from 'vue'\n\nexport function useHighlightTracker() {\n  const trackedElements = ref(new Map())\n  const isTrackingActive = ref(false)\n  \n  let resizeObserver = null\n  let mutationObserver = null\n  let scrollHandler = null\n  let rafId = null\n\n  const startTracking = (selector, callback, options = {}) => {\n    const element = document.querySelector(selector)\n    if (!element) return false\n\n    const trackingData = {\n      element,\n      selector,\n      callback,\n      options: {\n        padding: options.padding || 8,\n        throttle: options.throttle || 16, // ~60fps\n        ...options\n      },\n      lastBounds: null\n    }\n\n    trackedElements.value.set(selector, trackingData)\n    \n    // Initialize tracking systems if not already active\n    if (!isTrackingActive.value) {\n      initializeTracking()\n    }\n    \n    // Immediately calculate and callback with initial bounds\n    updateElementBounds(trackingData)\n    \n    return true\n  }\n\n  const stopTracking = (selector) => {\n    trackedElements.value.delete(selector)\n    \n    // Stop tracking if no elements remain\n    if (trackedElements.value.size === 0) {\n      cleanupTracking()\n    }\n  }\n\n  const stopAllTracking = () => {\n    trackedElements.value.clear()\n    cleanupTracking()\n  }\n\n  const initializeTracking = () => {\n    if (isTrackingActive.value) return\n    \n    isTrackingActive.value = true\n    \n    // ResizeObserver for element size changes\n    if (window.ResizeObserver) {\n      resizeObserver = new ResizeObserver((entries) => {\n        for (const entry of entries) {\n          const element = entry.target\n          const trackingData = findTrackingDataByElement(element)\n          if (trackingData) {\n            scheduleUpdate(trackingData)\n          }\n        }\n      })\n    }\n    \n    // MutationObserver for DOM changes that might affect position\n    mutationObserver = new MutationObserver((mutations) => {\n      let needsUpdate = false\n      \n      for (const mutation of mutations) {\n        if (mutation.type === 'childList' || \n            mutation.type === 'attributes' && \n            (mutation.attributeName === 'class' || \n             mutation.attributeName === 'style')) {\n          needsUpdate = true\n          break\n        }\n      }\n      \n      if (needsUpdate) {\n        scheduleUpdateAll()\n      }\n    })\n    \n    // Scroll handler for scroll-based position changes\n    scrollHandler = throttle(() => {\n      scheduleUpdateAll()\n    }, 16) // ~60fps\n    \n    // Start observing\n    if (resizeObserver) {\n      // Will be added per element\n    }\n    \n    mutationObserver.observe(document.body, {\n      childList: true,\n      subtree: true,\n      attributes: true,\n      attributeFilter: ['class', 'style', 'hidden']\n    })\n    \n    // Add scroll listeners to window and scrollable elements\n    window.addEventListener('scroll', scrollHandler, { passive: true })\n    document.addEventListener('scroll', scrollHandler, { passive: true, capture: true })\n  }\n\n  const cleanupTracking = () => {\n    if (!isTrackingActive.value) return\n    \n    isTrackingActive.value = false\n    \n    // Cleanup observers\n    if (resizeObserver) {\n      resizeObserver.disconnect()\n      resizeObserver = null\n    }\n    \n    if (mutationObserver) {\n      mutationObserver.disconnect()\n      mutationObserver = null\n    }\n    \n    // Remove scroll listeners\n    if (scrollHandler) {\n      window.removeEventListener('scroll', scrollHandler)\n      document.removeEventListener('scroll', scrollHandler, { capture: true })\n      scrollHandler = null\n    }\n    \n    // Cancel pending updates\n    if (rafId) {\n      cancelAnimationFrame(rafId)\n      rafId = null\n    }\n  }\n\n  const scheduleUpdate = (trackingData) => {\n    // Use RAF to batch updates and avoid excessive calculations\n    if (!rafId) {\n      rafId = requestAnimationFrame(() => {\n        updateElementBounds(trackingData)\n        rafId = null\n      })\n    }\n  }\n\n  const scheduleUpdateAll = () => {\n    if (!rafId) {\n      rafId = requestAnimationFrame(() => {\n        for (const trackingData of trackedElements.value.values()) {\n          updateElementBounds(trackingData)\n        }\n        rafId = null\n      })\n    }\n  }\n\n  const updateElementBounds = (trackingData) => {\n    const { element, callback, options, selector } = trackingData\n    \n    // Check if element is still in DOM\n    if (!document.contains(element)) {\n      console.warn(`[HighlightTracker] Element ${selector} no longer in DOM, stopping tracking`)\n      stopTracking(selector)\n      return\n    }\n    \n    // Check if element is visible\n    const style = window.getComputedStyle(element)\n    if (style.display === 'none' || style.visibility === 'hidden') {\n      return\n    }\n    \n    const rect = element.getBoundingClientRect()\n    const padding = options.padding\n    \n    const bounds = {\n      top: rect.top - padding,\n      left: rect.left - padding,\n      width: rect.width + (padding * 2),\n      height: rect.height + (padding * 2)\n    }\n    \n    // Only callback if bounds actually changed (avoid unnecessary updates)\n    if (!trackingData.lastBounds || \n        !boundsEqual(bounds, trackingData.lastBounds)) {\n      trackingData.lastBounds = { ...bounds }\n      callback(bounds, element)\n    }\n  }\n\n  const findTrackingDataByElement = (element) => {\n    for (const trackingData of trackedElements.value.values()) {\n      if (trackingData.element === element) {\n        return trackingData\n      }\n    }\n    return null\n  }\n\n  const boundsEqual = (a, b) => {\n    return Math.abs(a.top - b.top) < 1 &&\n           Math.abs(a.left - b.left) < 1 &&\n           Math.abs(a.width - b.width) < 1 &&\n           Math.abs(a.height - b.height) < 1\n  }\n\n  const throttle = (func, wait) => {\n    let timeout\n    let lastExecTime = 0\n    \n    return function executedFunction(...args) {\n      const currentTime = Date.now()\n      \n      if (currentTime - lastExecTime > wait) {\n        func.apply(this, args)\n        lastExecTime = currentTime\n      } else {\n        clearTimeout(timeout)\n        timeout = setTimeout(() => {\n          func.apply(this, args)\n          lastExecTime = Date.now()\n        }, wait - (currentTime - lastExecTime))\n      }\n    }\n  }\n\n  // Cleanup on unmount\n  onUnmounted(() => {\n    cleanupTracking()\n  })\n\n  return {\n    startTracking,\n    stopTracking,\n    stopAllTracking,\n    isTrackingActive,\n    trackedElements: trackedElements.value\n  }\n}","import { ref, computed, watch, onErrorCaptured } from 'vue'\n\nimport { useUIStore } from '@/stores/useUIStore'\n\n// Enhanced error handling composable for Phase 5\nexport function useErrorHandling(options = {}) {\n  const {\n    showNotifications = true,\n    logToConsole = true,\n    retryAttempts = 3,\n    retryDelay = 1000,\n    persistErrors = true\n  } = options\n\n  const uiStore = useUIStore()\n\n  // Error state\n  const errors = ref([])\n  const globalError = ref(null)\n  const errorCounts = ref(new Map())\n  const retryHistory = ref(new Map())\n  const errorMetrics = ref({\n    total: 0,\n    byType: {},\n    byComponent: {},\n    resolved: 0,\n    unresolved: 0\n  })\n\n  // Error categories\n  const ERROR_TYPES = {\n    NETWORK: 'network',\n    VALIDATION: 'validation',\n    RUNTIME: 'runtime',\n    PERMISSION: 'permission',\n    DATA: 'data',\n    VISUALIZATION: 'visualization',\n    STORE: 'store',\n    UNKNOWN: 'unknown'\n  }\n\n  const ERROR_SEVERITY = {\n    LOW: 'low',\n    MEDIUM: 'medium',\n    HIGH: 'high',\n    CRITICAL: 'critical'\n  }\n\n  // Computed properties\n  const hasErrors = computed(() => errors.value.length > 0)\n  const hasGlobalError = computed(() => globalError.value !== null)\n  const criticalErrors = computed(() => \n    errors.value.filter(error => error.severity === ERROR_SEVERITY.CRITICAL)\n  )\n  const unresolvedErrors = computed(() => \n    errors.value.filter(error => !error.resolved)\n  )\n\n  // Error classification\n  const classifyError = (error, context = {}) => {\n    let type = ERROR_TYPES.UNKNOWN\n    let severity = ERROR_SEVERITY.MEDIUM\n\n    const message = error.message || error.toString()\n    const stack = error.stack || ''\n\n    // Network errors\n    if (message.includes('network') || \n        message.includes('fetch') || \n        message.includes('timeout') ||\n        message.includes('connection')) {\n      type = ERROR_TYPES.NETWORK\n      severity = ERROR_SEVERITY.HIGH\n    }\n    // Validation errors\n    else if (message.includes('validation') || \n             message.includes('invalid') || \n             message.includes('required')) {\n      type = ERROR_TYPES.VALIDATION\n      severity = ERROR_SEVERITY.LOW\n    }\n    // Permission errors\n    else if (message.includes('permission') || \n             message.includes('unauthorized') || \n             message.includes('forbidden')) {\n      type = ERROR_TYPES.PERMISSION\n      severity = ERROR_SEVERITY.HIGH\n    }\n    // Data errors\n    else if (message.includes('data') || \n             message.includes('parse') || \n             message.includes('format')) {\n      type = ERROR_TYPES.DATA\n      severity = ERROR_SEVERITY.MEDIUM\n    }\n    // Visualization errors\n    else if (stack.includes('d3') || \n             stack.includes('visualization') ||\n             context.component?.includes('Chart') ||\n             context.component?.includes('Map')) {\n      type = ERROR_TYPES.VISUALIZATION\n      severity = ERROR_SEVERITY.MEDIUM\n    }\n    // Store errors\n    else if (stack.includes('store') || \n             stack.includes('pinia') ||\n             context.store) {\n      type = ERROR_TYPES.STORE\n      severity = ERROR_SEVERITY.HIGH\n    }\n    // Runtime errors\n    else if (error instanceof TypeError || \n             error instanceof ReferenceError || \n             error instanceof RangeError) {\n      type = ERROR_TYPES.RUNTIME\n      severity = ERROR_SEVERITY.HIGH\n    }\n\n    // Increase severity for repeated errors\n    const errorKey = `${type}_${message.substring(0, 50)}`\n    const count = errorCounts.value.get(errorKey) || 0\n    if (count > 3) {\n      severity = ERROR_SEVERITY.CRITICAL\n    }\n\n    return { type, severity }\n  }\n\n  // Create standardized error object\n  const createErrorObject = (error, context = {}) => {\n    const { type, severity } = classifyError(error, context)\n    \n    return {\n      id: Date.now() + Math.random(),\n      message: error.message || error.toString(),\n      stack: error.stack || '',\n      type,\n      severity,\n      context,\n      timestamp: new Date(),\n      resolved: false,\n      retryCount: 0,\n      userAgent: typeof navigator !== 'undefined' ? navigator.userAgent : '',\n      url: typeof window !== 'undefined' ? window.location.href : '',\n      component: context.component || 'unknown',\n      action: context.action || 'unknown'\n    }\n  }\n\n  // Handle error\n  const handleError = (error, context = {}) => {\n    const errorObj = createErrorObject(error, context)\n    \n    // Update error counts\n    const errorKey = `${errorObj.type}_${errorObj.message.substring(0, 50)}`\n    errorCounts.value.set(errorKey, (errorCounts.value.get(errorKey) || 0) + 1)\n    \n    // Add to errors list\n    errors.value.push(errorObj)\n    \n    // Update metrics\n    updateErrorMetrics(errorObj)\n    \n    // Log to console if enabled\n    if (logToConsole) {\n      console.error(`[${errorObj.severity.toUpperCase()}] ${errorObj.type}:`, errorObj.message)\n      if (errorObj.stack) {\n        console.error('Stack trace:', errorObj.stack)\n      }\n      console.error('Context:', errorObj.context)\n    }\n    \n    // Show notification if enabled\n    if (showNotifications) {\n      showErrorNotification(errorObj)\n    }\n    \n    // Set global error for critical errors\n    if (errorObj.severity === ERROR_SEVERITY.CRITICAL) {\n      globalError.value = errorObj\n    }\n    \n    // Persist error if enabled\n    if (persistErrors) {\n      persistError(errorObj)\n    }\n    \n    // Limit error history\n    if (errors.value.length > 100) {\n      errors.value = errors.value.slice(-50)\n    }\n    \n    return errorObj\n  }\n\n  // Update error metrics\n  const updateErrorMetrics = (errorObj) => {\n    errorMetrics.value.total++\n    \n    // By type\n    if (!errorMetrics.value.byType[errorObj.type]) {\n      errorMetrics.value.byType[errorObj.type] = 0\n    }\n    errorMetrics.value.byType[errorObj.type]++\n    \n    // By component\n    if (!errorMetrics.value.byComponent[errorObj.component]) {\n      errorMetrics.value.byComponent[errorObj.component] = 0\n    }\n    errorMetrics.value.byComponent[errorObj.component]++\n    \n    // Update resolved/unresolved counts\n    errorMetrics.value.unresolved = unresolvedErrors.value.length\n    errorMetrics.value.resolved = errors.value.length - errorMetrics.value.unresolved\n  }\n\n  // Show error notification\n  const showErrorNotification = (errorObj) => {\n    let title = 'Error'\n    let type = 'error'\n    let duration = 5000\n    \n    switch (errorObj.severity) {\n      case ERROR_SEVERITY.LOW:\n        title = 'Warning'\n        type = 'warning'\n        duration = 3000\n        break\n      case ERROR_SEVERITY.MEDIUM:\n        title = 'Error'\n        type = 'error'\n        duration = 5000\n        break\n      case ERROR_SEVERITY.HIGH:\n        title = 'Serious Error'\n        type = 'error'\n        duration = 8000\n        break\n      case ERROR_SEVERITY.CRITICAL:\n        title = 'Critical Error'\n        type = 'error'\n        duration = 0 // Don't auto-hide\n        break\n    }\n    \n  }\n\n  // Show error details\n  const showErrorDetails = (errorId) => {\n    const error = errors.value.find(e => e.id === errorId)\n    if (!error) return\n    \n    uiStore.openModal('error-details', {\n      error,\n      title: 'Error Details',\n      component: 'ErrorDetailsModal'\n    })\n  }\n\n  // Retry operation\n  const retryOperation = async (errorId) => {\n    const error = errors.value.find(e => e.id === errorId)\n    if (!error?.context.retryFn) return\n    \n    const retryKey = `${error.type}_${error.message.substring(0, 30)}`\n    const retryCount = retryHistory.value.get(retryKey) || 0\n    \n    if (retryCount >= retryAttempts) {\n      return\n    }\n    \n    try {\n      // Increment retry count\n      retryHistory.value.set(retryKey, retryCount + 1)\n      error.retryCount++\n      \n      // Wait before retry with exponential backoff\n      const delay = retryDelay * Math.pow(2, retryCount)\n      await new Promise(resolve => setTimeout(resolve, delay))\n      \n      // Execute retry function\n      await error.context.retryFn()\n      \n      // Mark error as resolved\n      resolveError(errorId)\n      \n      \n    } catch (retryError) {\n      handleError(retryError, {\n        ...error.context,\n        action: 'retry',\n        originalError: error.id\n      })\n    }\n  }\n\n  // Resolve error\n  const resolveError = (errorId) => {\n    const error = errors.value.find(e => e.id === errorId)\n    if (error) {\n      error.resolved = true\n      error.resolvedAt = new Date()\n      \n      // Clear global error if resolved\n      if (globalError.value && globalError.value.id === errorId) {\n        globalError.value = null\n      }\n      \n      updateErrorMetrics(error)\n    }\n  }\n\n  // Clear errors\n  const clearErrors = (filter = null) => {\n    if (filter) {\n      errors.value = errors.value.filter(error => !filter(error))\n    } else {\n      errors.value = []\n      globalError.value = null\n      errorCounts.value.clear()\n      retryHistory.value.clear()\n    }\n  }\n\n  // Persist error to local storage\n  const persistError = (errorObj) => {\n    try {\n      const persistedErrors = JSON.parse(\n        localStorage.getItem('d2-error-log') || '[]'\n      )\n      \n      persistedErrors.push({\n        ...errorObj,\n        stack: errorObj.stack.substring(0, 500) // Limit stack size\n      })\n      \n      // Keep only last 50 errors\n      const limitedErrors = persistedErrors.slice(-50)\n      \n      localStorage.setItem('d2-error-log', JSON.stringify(limitedErrors))\n    } catch (e) {\n      console.warn('Failed to persist error:', e)\n    }\n  }\n\n  // Load persisted errors\n  const loadPersistedErrors = () => {\n    try {\n      const persistedErrors = JSON.parse(\n        localStorage.getItem('d2-error-log') || '[]'\n      )\n      \n      return persistedErrors.map(error => ({\n        ...error,\n        timestamp: new Date(error.timestamp),\n        resolvedAt: error.resolvedAt ? new Date(error.resolvedAt) : null\n      }))\n    } catch (e) {\n      console.warn('Failed to load persisted errors:', e)\n      return []\n    }\n  }\n\n  // Async error wrapper with automatic retry\n  const wrapAsync = (asyncFn, context = {}) => {\n    return async (...args) => {\n      const { autoRetry = false, maxRetries = 3, retryDelay = 1000 } = context\n      let lastError = null\n      \n      for (let attempt = 0; attempt <= (autoRetry ? maxRetries : 0); attempt++) {\n        try {\n          return await asyncFn(...args)\n        } catch (error) {\n          lastError = error\n          \n          // Handle error on first attempt or if retries are disabled\n          if (attempt === 0 || !autoRetry) {\n            handleError(error, {\n              ...context,\n              retryFn: () => asyncFn(...args),\n              attempt: attempt + 1\n            })\n          }\n          \n          // If this is not the last attempt and auto-retry is enabled\n          if (attempt < maxRetries && autoRetry) {\n            console.log(`Retrying operation (attempt ${attempt + 2}/${maxRetries + 1})...`)\n            const delay = retryDelay * Math.pow(2, attempt) // Exponential backoff\n            await new Promise(resolve => setTimeout(resolve, delay))\n            continue\n          }\n          \n          break\n        }\n      }\n      \n      throw lastError\n    }\n  }\n\n  // Graceful degradation wrapper\n  const withGracefulDegradation = (asyncFn, fallbackValue = null, context = {}) => {\n    return async (...args) => {\n      try {\n        return await asyncFn(...args)\n      } catch (error) {\n        const errorObj = handleError(error, {\n          ...context,\n          degraded: true,\n          fallbackUsed: true\n        })\n        \n        // Log degradation\n        console.warn(`Graceful degradation activated for ${context.operation || 'operation'}:`, error.message)\n        \n        // Return fallback value\n        if (typeof fallbackValue === 'function') {\n          return fallbackValue(error, ...args)\n        }\n        \n        return fallbackValue\n      }\n    }\n  }\n\n  // Circuit breaker pattern for repeated failures\n  const createCircuitBreaker = (asyncFn, options = {}) => {\n    const {\n      failureThreshold = 5,\n      resetTimeout = 60000,\n      monitoringPeriod = 30000\n    } = options\n\n    let failureCount = 0\n    let lastFailureTime = null\n    let state = 'CLOSED' // CLOSED, OPEN, HALF_OPEN\n    let nextAttempt = Date.now()\n\n    return async (...args) => {\n      const now = Date.now()\n\n      // Reset failure count after monitoring period\n      if (lastFailureTime && (now - lastFailureTime) > monitoringPeriod && state === 'CLOSED') {\n        failureCount = 0\n      }\n\n      // Circuit is OPEN - check if we should attempt reset\n      if (state === 'OPEN') {\n        if (now < nextAttempt) {\n          throw new Error('Circuit breaker is OPEN - operation temporarily unavailable')\n        }\n        state = 'HALF_OPEN'\n      }\n\n      try {\n        const result = await asyncFn(...args)\n        \n        // Success - reset circuit breaker\n        if (state === 'HALF_OPEN') {\n          state = 'CLOSED'\n          failureCount = 0\n        }\n        \n        return result\n      } catch (error) {\n        failureCount++\n        lastFailureTime = now\n\n        if (failureCount >= failureThreshold) {\n          state = 'OPEN'\n          nextAttempt = now + resetTimeout\n          \n          handleError(new Error(`Circuit breaker OPEN: ${failureCount} failures detected`), {\n            component: 'circuit-breaker',\n            originalError: error.message,\n            action: 'circuit_open'\n          })\n        }\n\n        throw error\n      }\n    }\n  }\n\n  // Component error boundary\n  const createErrorBoundary = (component, fallbackComponent = null) => {\n    const boundaryError = ref(null)\n    \n    onErrorCaptured((error, instance, info) => {\n      boundaryError.value = handleError(error, {\n        component: component || instance?.$options.name || 'Unknown',\n        errorInfo: info,\n        instance\n      })\n      \n      // Return false to prevent error propagation\n      return false\n    })\n    \n    return {\n      boundaryError,\n      clearBoundaryError: () => { boundaryError.value = null }\n    }\n  }\n\n  // Error recovery suggestions\n  const getRecoverySuggestions = (errorObj) => {\n    const suggestions = []\n    \n    switch (errorObj.type) {\n      case ERROR_TYPES.NETWORK:\n        suggestions.push('Check your internet connection')\n        suggestions.push('Try refreshing the page')\n        suggestions.push('Wait a moment and try again')\n        break\n      case ERROR_TYPES.DATA:\n        suggestions.push('Verify the data format')\n        suggestions.push('Check if all required fields are present')\n        suggestions.push('Try loading different data')\n        break\n      case ERROR_TYPES.VISUALIZATION:\n        suggestions.push('Try resizing the window')\n        suggestions.push('Check if data is properly formatted')\n        suggestions.push('Try switching to a different visualization')\n        break\n      case ERROR_TYPES.PERMISSION:\n        suggestions.push('Check your access permissions')\n        suggestions.push('Try logging in again')\n        suggestions.push('Contact your administrator')\n        break\n      default:\n        suggestions.push('Try refreshing the page')\n        suggestions.push('Clear your browser cache')\n        suggestions.push('Contact support if the problem persists')\n    }\n    \n    return suggestions\n  }\n\n  // Initialize error handling\n  const initializeErrorHandling = () => {\n    // Global error handler\n    if (typeof window !== 'undefined') {\n      window.addEventListener('error', (event) => {\n        handleError(event.error || new Error(event.message), {\n          component: 'global',\n          action: 'unhandled_error',\n          filename: event.filename,\n          lineno: event.lineno,\n          colno: event.colno\n        })\n      })\n      \n      window.addEventListener('unhandledrejection', (event) => {\n        handleError(event.reason || new Error('Unhandled promise rejection'), {\n          component: 'global',\n          action: 'unhandled_rejection'\n        })\n      })\n    }\n  }\n\n  return {\n    // State\n    errors,\n    globalError,\n    errorMetrics,\n    \n    // Computed\n    hasErrors,\n    hasGlobalError,\n    criticalErrors,\n    unresolvedErrors,\n    \n    // Error handling\n    handleError,\n    resolveError,\n    clearErrors,\n    \n    // Retry mechanism\n    retryOperation,\n    \n    // Utilities\n    wrapAsync,\n    withGracefulDegradation,\n    createCircuitBreaker,\n    createErrorBoundary,\n    getRecoverySuggestions,\n    showErrorDetails,\n    \n    // Persistence\n    loadPersistedErrors,\n    \n    // Constants\n    ERROR_TYPES,\n    ERROR_SEVERITY,\n    \n    // Initialization\n    initializeErrorHandling\n  }\n}","import { ref, onMounted, onUnmounted, nextTick, watch } from 'vue'\nimport * as d3 from 'd3'\n\n/**\n * Core D3.js lifecycle management composable\n * Provides reactive D3.js integration with Vue.js components\n */\nexport function useD3(containerRef, options = {}) {\n  const {\n    responsive = true,\n    debounceResize = 250,\n    cleanupSelectors = [],\n    autoResize = true\n  } = options\n\n  // Reactive state\n  const dimensions = ref({ width: 0, height: 0 })\n  const isReady = ref(false)\n  const isDestroyed = ref(false)\n\n  // Internal state\n  let resizeObserver = null\n  let resizeTimeout = null\n  const d3Selections = new Map()\n  const eventListeners = new Map()\n\n  /**\n   * Initialize D3.js container and setup\n   */\n  const initialize = async () => {\n    if (!containerRef.value || isDestroyed.value) return\n\n    await nextTick()\n\n    // Get initial dimensions\n    updateDimensions()\n\n    // Setup resize observer for responsive behavior\n    if (responsive && autoResize) {\n      setupResizeObserver()\n    }\n\n    isReady.value = true\n  }\n\n  /**\n   * Update container dimensions\n   */\n  const updateDimensions = () => {\n    if (!containerRef.value) return\n\n    const rect = containerRef.value.getBoundingClientRect()\n    dimensions.value = {\n      width: rect.width,\n      height: rect.height\n    }\n  }\n\n  /**\n   * Setup resize observer for responsive charts\n   */\n  const setupResizeObserver = () => {\n    if (!window.ResizeObserver || !containerRef.value) return\n\n    resizeObserver = new ResizeObserver(() => {\n      if (resizeTimeout) clearTimeout(resizeTimeout)\n      \n      resizeTimeout = setTimeout(() => {\n        updateDimensions()\n      }, debounceResize)\n    })\n\n    resizeObserver.observe(containerRef.value)\n  }\n\n  /**\n   * Create and register a D3.js selection\n   */\n  const createSelection = (selector, key = null) => {\n    if (!containerRef.value) return null\n\n    const selection = d3.select(containerRef.value).select(selector)\n    \n    if (key) {\n      d3Selections.set(key, selection)\n    }\n\n    return selection\n  }\n\n  /**\n   * Get a registered D3.js selection\n   */\n  const getSelection = (key) => {\n    return d3Selections.get(key)\n  }\n\n  /**\n   * Create SVG element with proper setup\n   */\n  const createSVG = (options = {}) => {\n    const {\n      width = dimensions.value.width,\n      height = dimensions.value.height,\n      margin = { top: 20, right: 20, bottom: 20, left: 20 },\n      className = 'chart-svg',\n      preserveAspectRatio = 'xMidYMid meet'\n    } = options\n\n    if (!containerRef.value) {\n      console.error('❌ useD3: No container reference available')\n      return null\n    }\n\n    // Remove existing SVG\n    const existingSvg = d3.select(containerRef.value).select('svg')\n    existingSvg.remove()\n\n    // Create new SVG\n    const svg = d3.select(containerRef.value)\n      .append('svg')\n      .attr('class', className)\n      .attr('width', width)\n      .attr('height', height)\n      .attr('viewBox', `0 0 ${width} ${height}`)\n      .attr('preserveAspectRatio', preserveAspectRatio)\n\n    // Create main group with margins\n    const g = svg.append('g')\n      .attr('class', 'chart-container')\n      .attr('transform', `translate(${margin.left}, ${margin.top})`)\n\n    // Store selections\n    d3Selections.set('svg', svg)\n    d3Selections.set('container', g)\n\n    return { svg, g, width, height, margin }\n  }\n\n  /**\n   * Add event listener with cleanup tracking\n   */\n  const addEventListener = (element, event, handler, key = null) => {\n    if (!element || typeof handler !== 'function') return\n\n    element.addEventListener(event, handler)\n\n    // Track for cleanup\n    const listenerKey = key || `${event}_${Date.now()}`\n    eventListeners.set(listenerKey, { element, event, handler })\n\n    return listenerKey\n  }\n\n  /**\n   * Remove tracked event listener\n   */\n  const removeEventListener = (key) => {\n    const listener = eventListeners.get(key)\n    if (listener) {\n      listener.element.removeEventListener(listener.event, listener.handler)\n      eventListeners.delete(key)\n    }\n  }\n\n  /**\n   * Create transition with consistent settings\n   */\n  const createTransition = (options = {}) => {\n    const {\n      duration = 750,\n      ease = d3.easeQuadInOut,\n      delay = 0\n    } = options\n\n    return d3.transition()\n      .duration(duration)\n      .ease(ease)\n      .delay(delay)\n  }\n\n  /**\n   * Cleanup all D3.js resources\n   */\n  const cleanup = () => {\n    if (isDestroyed.value) return\n\n    // Mark as destroyed\n    isDestroyed.value = true\n    isReady.value = false\n\n    // Clear resize observer\n    if (resizeObserver) {\n      resizeObserver.disconnect()\n      resizeObserver = null\n    }\n\n    // Clear resize timeout\n    if (resizeTimeout) {\n      clearTimeout(resizeTimeout)\n      resizeTimeout = null\n    }\n\n    // Remove event listeners\n    eventListeners.forEach((listener, key) => {\n      removeEventListener(key)\n    })\n    eventListeners.clear()\n\n    // Clean up D3 selections\n    d3Selections.forEach((selection) => {\n      try {\n        selection.remove()\n      } catch (error) {\n        console.warn('Error removing D3 selection:', error)\n      }\n    })\n    d3Selections.clear()\n\n    // Clean up custom selectors\n    if (containerRef.value) {\n      cleanupSelectors.forEach(selector => {\n        try {\n          d3.select(containerRef.value).selectAll(selector).remove()\n        } catch (error) {\n          console.warn(`Error cleaning up selector ${selector}:`, error)\n        }\n      })\n\n      // Remove all SVG elements\n      d3.select(containerRef.value).selectAll('svg').remove()\n    }\n  }\n\n  // Lifecycle hooks\n  onMounted(() => {\n    initialize()\n  })\n\n  onUnmounted(() => {\n    cleanup()\n  })\n\n  return {\n    // Reactive state\n    dimensions,\n    isReady,\n    isDestroyed,\n\n    // Core methods\n    initialize,\n    updateDimensions,\n    cleanup,\n\n    // D3 utilities\n    createSelection,\n    getSelection,\n    createSVG,\n    createTransition,\n\n    // Event management\n    addEventListener,\n    removeEventListener,\n\n    // D3 library access\n    d3\n  }\n}\n\n/**\n * Reactive data binding composable for D3.js\n * Handles Vue reactivity with D3.js data updates with performance optimizations\n */\nexport function useD3Data(data, options = {}) {\n  const {\n    key = 'd3-data',\n    transform = null,\n    debounce = 50,\n    enableCaching = true,\n    maxCacheSize = 100,\n    enableVirtualization = false,\n    virtualPageSize = 1000\n  } = options\n\n  const processedData = ref([])\n  const isProcessing = ref(false)\n  const dataCache = ref(new Map())\n  const cacheHits = ref(0)\n  const cacheMisses = ref(0)\n  \n  let debounceTimeout = null\n  let lastDataHash = null\n\n  /**\n   * Generate hash for data caching\n   */\n  const generateDataHash = (data) => {\n    if (!data) return 'empty'\n    if (Array.isArray(data)) {\n      return `array_${data.length}_${JSON.stringify(data.slice(0, 3))}`\n    }\n    return JSON.stringify(data).substring(0, 100)\n  }\n\n  /**\n   * Get cached data or compute new result\n   */\n  const getCachedOrCompute = (data, transform) => {\n    if (!enableCaching) {\n      return transform ? transform(data) : data\n    }\n\n    const dataHash = generateDataHash(data)\n    const transformHash = transform ? transform.toString() : 'none'\n    const cacheKey = `${dataHash}_${transformHash}`\n\n    // Check cache\n    if (dataCache.value.has(cacheKey)) {\n      cacheHits.value++\n      return dataCache.value.get(cacheKey)\n    }\n\n    // Compute new result\n    cacheMisses.value++\n    const result = transform ? transform(data) : data\n\n    // Store in cache (with size limit)\n    if (dataCache.value.size >= maxCacheSize) {\n      const firstKey = dataCache.value.keys().next().value\n      dataCache.value.delete(firstKey)\n    }\n    dataCache.value.set(cacheKey, result)\n\n    return result\n  }\n\n  /**\n   * Apply virtualization to large datasets\n   */\n  const virtualizeData = (data, pageIndex = 0) => {\n    if (!enableVirtualization || !Array.isArray(data)) {\n      return data\n    }\n\n    if (data.length <= virtualPageSize) {\n      return data\n    }\n\n    const startIndex = pageIndex * virtualPageSize\n    const endIndex = Math.min(startIndex + virtualPageSize, data.length)\n    \n    return {\n      data: data.slice(startIndex, endIndex),\n      totalItems: data.length,\n      pageIndex,\n      pageSize: virtualPageSize,\n      totalPages: Math.ceil(data.length / virtualPageSize),\n      hasMore: endIndex < data.length\n    }\n  }\n\n  /**\n   * Process data with optional transformation and optimizations\n   */\n  const processData = (forceRefresh = false) => {\n    if (debounceTimeout) clearTimeout(debounceTimeout)\n\n    debounceTimeout = setTimeout(() => {\n      isProcessing.value = true\n\n      try {\n        const currentData = data.value\n        const currentHash = generateDataHash(currentData)\n\n        // Skip processing if data hasn't changed (unless forced)\n        if (!forceRefresh && currentHash === lastDataHash) {\n          isProcessing.value = false\n          return\n        }\n\n        lastDataHash = currentHash\n\n        let result = Array.isArray(currentData) ? [...currentData] : currentData\n\n        // Apply caching and transformation\n        result = getCachedOrCompute(result, transform)\n\n        // Apply virtualization if enabled\n        if (enableVirtualization && Array.isArray(result)) {\n          result = virtualizeData(result)\n        }\n\n        processedData.value = result\n\n        // Emit performance metrics\n        console.log(`D3 Data Processing: Cache hits: ${cacheHits.value}, misses: ${cacheMisses.value}`)\n        \n      } catch (error) {\n        console.error('Error processing D3 data:', error)\n        processedData.value = enableVirtualization ? { data: [], totalItems: 0 } : []\n      } finally {\n        isProcessing.value = false\n      }\n    }, debounce)\n  }\n\n  /**\n   * Load next page for virtualized data\n   */\n  const loadNextPage = () => {\n    if (!enableVirtualization || !processedData.value?.hasMore) return\n\n    const currentPageIndex = processedData.value.pageIndex || 0\n    const nextPageData = virtualizeData(data.value, currentPageIndex + 1)\n    \n    if (nextPageData.data.length > 0) {\n      processedData.value = {\n        ...nextPageData,\n        data: [...processedData.value.data, ...nextPageData.data]\n      }\n    }\n  }\n\n  /**\n   * Clear data cache\n   */\n  const clearCache = () => {\n    dataCache.value.clear()\n    cacheHits.value = 0\n    cacheMisses.value = 0\n  }\n\n  /**\n   * Get cache statistics\n   */\n  const getCacheStats = () => {\n    return {\n      size: dataCache.value.size,\n      hits: cacheHits.value,\n      misses: cacheMisses.value,\n      hitRate: cacheHits.value / (cacheHits.value + cacheMisses.value) || 0\n    }\n  }\n\n  // Watch for data changes with optimized comparison\n  watch(() => data.value, () => processData(), { \n    immediate: true,\n    deep: false // Use shallow watching for performance\n  })\n\n  onUnmounted(() => {\n    if (debounceTimeout) {\n      clearTimeout(debounceTimeout)\n    }\n    clearCache()\n  })\n\n  return {\n    processedData,\n    isProcessing,\n    processData,\n    loadNextPage,\n    clearCache,\n    getCacheStats,\n    // Virtualization helpers\n    isVirtualized: enableVirtualization,\n    virtualPageSize\n  }\n}\n\n/**\n * D3.js chart composable with common chart patterns\n * Provides reusable chart setup and update patterns\n */\nexport function useD3Chart(containerRef, options = {}) {\n  const {\n    margin = { top: 20, right: 20, bottom: 30, left: 40 },\n    responsive = true,\n    autoResize = true\n  } = options\n\n  const d3Instance = useD3(containerRef, { responsive, autoResize })\n  const chartState = ref({\n    scales: {},\n    axes: {},\n    elements: {}\n  })\n\n  /**\n   * Setup chart with scales and axes\n   */\n  const setupChart = (config = {}) => {\n    const {\n      xScale = null,\n      yScale = null,\n      colorScale = null,\n      xAxis = null,\n      yAxis = null\n    } = config\n\n    if (!d3Instance.isReady.value) return\n\n    const { width, height } = d3Instance.dimensions.value\n    const chartWidth = width - margin.left - margin.right\n    const chartHeight = height - margin.top - margin.bottom\n\n    // Create SVG if not exists\n    const { svg, g } = d3Instance.createSVG({ margin, width, height })\n\n    // Setup scales\n    if (xScale) {\n      chartState.value.scales.x = xScale.range([0, chartWidth])\n    }\n    if (yScale) {\n      chartState.value.scales.y = yScale.range([chartHeight, 0])\n    }\n    if (colorScale) {\n      chartState.value.scales.color = colorScale\n    }\n\n    // Setup axes\n    if (xAxis && chartState.value.scales.x) {\n      const xAxisGroup = g.append('g')\n        .attr('class', 'x-axis')\n        .attr('transform', `translate(0, ${chartHeight})`)\n        .call(xAxis.scale(chartState.value.scales.x))\n\n      chartState.value.axes.x = xAxisGroup\n    }\n\n    if (yAxis && chartState.value.scales.y) {\n      const yAxisGroup = g.append('g')\n        .attr('class', 'y-axis')\n        .call(yAxis.scale(chartState.value.scales.y))\n\n      chartState.value.axes.y = yAxisGroup\n    }\n\n    return { svg, g, chartWidth, chartHeight }\n  }\n\n  /**\n   * Update chart with new data\n   */\n  const updateChart = (data, updateFn) => {\n    if (!d3Instance.isReady.value || typeof updateFn !== 'function') return\n\n    const container = d3Instance.getSelection('container')\n    if (container) {\n      updateFn(container, data, chartState.value)\n    }\n  }\n\n  /**\n   * Resize chart\n   */\n  const resizeChart = () => {\n    if (!d3Instance.isReady.value) return\n\n    const { width, height } = d3Instance.dimensions.value\n    const chartWidth = width - margin.left - margin.right\n    const chartHeight = height - margin.top - margin.bottom\n\n    // Update SVG dimensions\n    const svg = d3Instance.getSelection('svg')\n    if (svg) {\n      svg.attr('width', width)\n         .attr('height', height)\n         .attr('viewBox', `0 0 ${width} ${height}`)\n    }\n\n    // Update scales ranges\n    if (chartState.value.scales.x) {\n      chartState.value.scales.x.range([0, chartWidth])\n    }\n    if (chartState.value.scales.y) {\n      chartState.value.scales.y.range([chartHeight, 0])\n    }\n\n    // Update axes\n    if (chartState.value.axes.x && chartState.value.scales.x) {\n      chartState.value.axes.x\n        .attr('transform', `translate(0, ${chartHeight})`)\n        .call(d3.axisBottom(chartState.value.scales.x))\n    }\n    if (chartState.value.axes.y && chartState.value.scales.y) {\n      chartState.value.axes.y.call(d3.axisLeft(chartState.value.scales.y))\n    }\n  }\n\n  // Watch for dimension changes\n  watch(() => d3Instance.dimensions.value, resizeChart, { deep: true })\n\n  return {\n    ...d3Instance,\n    chartState,\n    setupChart,\n    updateChart,\n    resizeChart,\n    margin\n  }\n}"],"names":["useDraggable","elementRef","options","initialPosition","x","y","handle","bounds","onDragStart","onDrag","onDragEnd","position","ref","isDragging","dragOffset","hasMoved","dragHandle","handleMouseDown","e","preventDefault","element","value","rect","getBoundingClientRect","clientX","left","clientY","top","document","addEventListener","handleMouseMove","handleMouseUp","body","style","cursor","newX","newY","padding","Math","max","min","window","innerWidth","width","innerHeight","height","removeEventListener","onMounted","querySelector","onUnmounted","setPosition","newPosition","useHighlightTracker","trackedElements","Map","isTrackingActive","resizeObserver","mutationObserver","scrollHandler","rafId","stopTracking","selector","delete","size","cleanupTracking","initializeTracking","ResizeObserver","entries","entry","target","trackingData","findTrackingDataByElement","scheduleUpdate","MutationObserver","mutations","needsUpdate","mutation","type","attributeName","scheduleUpdateAll","throttle","observe","childList","subtree","attributes","attributeFilter","passive","capture","disconnect","cancelAnimationFrame","requestAnimationFrame","updateElementBounds","values","callback","contains","getComputedStyle","display","visibility","lastBounds","boundsEqual","a","b","abs","func","wait","timeout","lastExecTime","args","currentTime","Date","now","apply","this","clearTimeout","setTimeout","startTracking","set","stopAllTracking","clear","useErrorHandling","showNotifications","logToConsole","retryAttempts","retryDelay","persistErrors","uiStore","useUIStore","errors","globalError","errorCounts","retryHistory","errorMetrics","total","byType","byComponent","resolved","unresolved","ERROR_TYPES","NETWORK","VALIDATION","RUNTIME","PERMISSION","DATA","VISUALIZATION","STORE","UNKNOWN","ERROR_SEVERITY","LOW","MEDIUM","HIGH","CRITICAL","hasErrors","computed","length","hasGlobalError","criticalErrors","filter","error","severity","unresolvedErrors","createErrorObject","context","message","toString","stack","includes","_a","component","_b","store","TypeError","ReferenceError","RangeError","errorKey","substring","get","classifyError","id","random","timestamp","retryCount","userAgent","navigator","url","location","href","action","handleError","errorObj","push","updateErrorMetrics","showErrorNotification","persistError","slice","resolveError","errorId","find","resolvedAt","persistedErrors","JSON","parse","localStorage","getItem","limitedErrors","setItem","stringify","clearErrors","retryOperation","async","retryFn","retryKey","delay","pow","Promise","resolve","retryError","originalError","wrapAsync","asyncFn","autoRetry","maxRetries","lastError","attempt","withGracefulDegradation","fallbackValue","degraded","fallbackUsed","createCircuitBreaker","failureThreshold","resetTimeout","monitoringPeriod","failureCount","lastFailureTime","state","nextAttempt","Error","result","createErrorBoundary","fallbackComponent","boundaryError","onErrorCaptured","instance","info","$options","name","errorInfo","clearBoundaryError","getRecoverySuggestions","suggestions","showErrorDetails","openModal","title","loadPersistedErrors","map","initializeErrorHandling","event","filename","lineno","colno","reason","useD3","containerRef","responsive","debounceResize","cleanupSelectors","autoResize","dimensions","isReady","isDestroyed","resizeTimeout","d3Selections","eventListeners","initialize","nextTick","updateDimensions","setupResizeObserver","key","listener","handler","cleanup","forEach","selection","remove","d3.select","selectAll","createSelection","select","getSelection","createSVG","margin","right","bottom","className","preserveAspectRatio","svg","append","attr","g","createTransition","duration","ease","d3.easeQuadInOut","d3.transition","listenerKey","d3"],"mappings":"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"}